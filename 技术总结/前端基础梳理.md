---
title: 前端基础梳理
description: 前端基础回顾的学习笔记
date: 2020-10-27 22:46:47
---

# 前端基础巩固

## this 指向

在 JavaScript 中，用 this 的表示当前执行代码的环境对象，主要存在于全局和函数中。

### 全局作用域

全局环境：this 指向全局对象，例如：浏览器中为 window 对象

```js
console.log(this === window); // true
```

### 函数作用域

函数作用域内：this 动态绑定，this 指向它绑定的对象

#### 独立函数

独立函数：没有被任何对象调用，该函数的 this 指向全局对象

```js
function fn1() {
  console.log(this === window); // true
  function fn2() {
    console.log(this === window); // true
  }
  fn2();
}
fn1();
```

> 在严格模式下，若 this 在没有被执行环境定义，则指向 undefined

```js
console.log(this === window); // true
function fn1() {
  console.log(this === window); // false
  function fn2() {
    console.log(this === window); // false
  }
  fn1();
}
fn2();
```

### 对象函数

对象函数：被对象调用的函数，该函数的 this 指向调用的对象

```js
var name = "out-name";
function fn1() {
  console.log(this.name);
}
var obj = {
  name: "in-name",
  fn: fn1,
};
var fn2 = obj.fn;
obj.fn();
fn2();
```

使用 call，apply，bind 改变 this 指向

```js
function add(b, c) {
  console.log(this.a + b + c);
}
var a = 1;
var obj = { a: 2 };
add.apply(obj, [1, 2]);
add.call(obj, 1, 2);
add(1, 2);
```

使用 bind 绑定 this 指向返回一个新的函数，且该函数的 this 会永久指向绑定的对象无法改变

```js
var a = 1;
function _add(b, c) {
  console.log(this.a + b + c);
}
var obj = { a: 2 };
var add = _add.bind(obj);
add(1, 2); // 2 + 1 + 2 this指向window

var obj2 = { a: 3 };

add.call(obj2, 1, 2); // 2 + 1 + 2 this指向obj
add.apply(obj2, [1, 2]); // 2 + 1 + 2 this指向obj
```

### 构造函数

当一个函数用作构造函数时，它的 this 指向 new 的新对象，如果构造函数没有返回值，则默认会返回构造出来的对象

```js
function Person(name) {
  this.name = name;
}
var feilong = new Person("飞龙");
console.log(feilong.name);

// function Person(name){
//     this.name = name;
// }
// function erzi(name) {
//     Person.call(this, name);
// }
// var a = new erzi('飞龙');
```

但是如果函数有返回值，则返回该值

```js
function Action(name) {
  this.name = name;
  return { name: "绩效" };
}
var action = new Action("工资");
console.log(action.name); // 绩效
```

### 箭头函数

箭头函数的 this 和所在的词法环境的 this 一致

```js
var obj = {
  name: "绩效",
  fn: function fn1() {
    return () => {
      console.log("fn2", this.name);
    };
  },
};
var name = "工资";
obj.fn()(); // 绩效
```

```js
var obj = {
  name: "绩效",
  fn: function fn1() {
    return function () {
      console.log(this.name);
    };
  },
};
var name = "工资";
obj.fn()(); // 工资 obj.fn() == fn1()  obj.fn()() == window.fn1()()
```

## 变量提升

> JavaScript 在执行前会先被引擎进行编译，包含变量和函数在内的所有声明都会在执行前被处理

```js
var a = 2;
console.log(a); // 2

// 等价于

var a;
a = 2;
console.log(a); // 2
```

代码在真正执行之前变量已经进行了提升声明

```js
console.log(a); // undefined
var a = 2;
```

```js
fn();
function fn() {
  console.log(a);
  var a = 2;
}
```

报错类型

- ReferenceError：同作用域判断失败相关，如使用了未声明的变量
- TypeError：作用域判别成功，但是对结果的操作非法或者不合理

```js
console.log(b); // ReferenceError

var a;
a(); // TypeError
```

优先级

后面的函数声明 > 函数声明 > 变量声明

```js
console.log(a); // a(){}
function a() {
  console.log("function");
}
var a = "var";
```

```js
fn1();
function fn1() {
  console.log("function");
}
var fn1 = function () {
  console.log("var");
};
```

```js
// 事件循环：先执行for，setTimeout等待500毫秒的console进入消息队列，i因为var变量提升使用的是同一个
for (var i = 0; i < 5; i++) {
  setTimeout(function () {
    console.log("in-i:", i++);
  }, 500);
  console.log("out-i:", i);
}
console.log("window-i:", i);
```

```js
for (var i = 0; i < 5; i++) {
  (function (j) {
    // 使用自执行函数，原理相当于下个代码块
    setTimeout(function () {
      console.log(j++);
    }, 500);
  })(i);
}
console.log(i);
```

```js
for (var i = 0; i < 5; i++) {
  var a = function () {
    var j = i;
    setTimeout(function () {
      console.log(++j);
    }, 500);
  };
  a();
}
```

```js
let arr = [];
for (var i = 0; i < 5; i++) {
  arr.push(function () {
    return i;
  });
  // 使用自执行或者换成let i = 0;
  // (function(i){
  //   arr.push(function () {
  //     return i;
  //   });
  // })(i)
}
console.log("i:", i);
console.log("arr[0]:", arr[0]()); // 从全局作用域找到的i，因为push的原因i被保留了，因此会是5
```

> let,const 存在变量提升么？

参考资料：https://es6.ruanyifeng.com/#docs/let

```js
console.log(a); // 输出什么？
let a = "let";
```

```js
var a = "out";
if (true) {
  a = "in";
  console.log(a); // 输出什么？
  let a; // 改成var呢？
}
```

```js
// 事件循环：先执行for，setTimeout等待500毫秒的console进入消息队列，i因为块级作用域以独立
for (let i = 0; i < 5; i++) {
  setTimeout(function () {
    console.log("in-i:", i++);
  }, 500);
  console.log("out-i:", i);
}
console.log("window-i:", i);
```

## 原型与原型链

在 JavaScript 中的对象，可以分为普通对象和函数对象，对象都有`__proto__`属性

- 函数对象：使用`new Function()`创建的对象，有`prototype`属性，其中`Function`，`Object`是 JS 自带的函数对象
- 普通对象：其他的普通对象，

### 构造函数

构造函数可用来创建特定类型的对象

```js
function Person() {
  this.name = "原型";
}
let ashen = new Person(); // 创建实例
// 实例ashen继承了Person原型上所定义的属性，通过继承，实例ashen拥有了其属性。
console.log(ashen.__proto__ == Person.prototype); // true
```

继承的行为是在 new 操作符内部实现的，可以从下述手写 new 的过程进行理解

```js
// 手写new
function Student(name, age) {
  this.name = name;
  this.age = age;
}
function myNew() {
  const obj = new Object(); // 创建空对象
  Constructor = Array.prototype.shift.call(arguments); // 把形参argument的第一个参数作为构造函数，shift操作会改变原数组
  obj.__proto__ = Constructor.prototype; // obj通过__proto__继承构造函数的原型
  Constructor.apply(obj, arguments); // this指向obj，将obj的属性覆写构造函数自身的
  return obj;
}
let newPerson = myNew(Student, "hanson", 18);
console.log(newPerson.name); // hanson
```

## 深拷贝与浅拷贝

js 数据类型：7 种 = 基本数据类型（Number、String 、Boolean、Null、Undefined 及 ES6 新增的 Symbol 类型） + 复杂数据类型（Object：普通对象，数组对象，正则对象，Data 日期对象及 ES6 新增的 Set，Map 等等）

- 基本类型：按值存放，直接访问传值
- 引用类型：在栈中存在的是地址，按照地址访问相应的值

### 直接引用

```js
let a = "a";
let b = "b";
b = "c";
console.log(a); // a
```

```js
let a = {
  name: "a",
  children: {
    name: "a1",
  },
};
let b = a;
b.name = "b";
console.log(a); // a = {name:'b'...}
```

### 浅拷贝

拷贝所有的属性值到新的对象中，如果属性值是对象，则拷贝的是地址

浅拷贝的方法：`Object.assign({},obj)`，展开运算符等，其中，数组可以使用`concat`,`slice`,

```js
// Object.assign
let a = {
  name: "a",
  children: {
    name: "a1",
  },
};
let b = Object.assign({}, a);
b.name = "b";
b.children.name = "b1";
console.log(a);
```

```js
// ...扩展运算符
let a = {
  name: "a",
  children: {
    name: "a1",
  },
};
let b = { ...a };
b.name = "b";
b.children.name = "b1";
console.log(a);
```

```js
// concat
let a = ["a1", { name: "a2" }, [{ name: "a3" }]];
let b = [].concat(a);
b[0] = "b1";
b[1].name = "b2";
b[2][0].name = "b3";
console.log(a);
```

```js
// slice
let a = ["a1", { name: "a2" }, [{ name: "a3" }]];
let b = a.slice();
b[0] = "b1";
b[1].name = "b2";
b[2][0].name = "b3";
console.log(a);
```

```js
// 手动实现
function shallowCopy(obj) {
  let temp = {};
  for (let key in obj) {
    temp[key] = obj[key];
  }
  return temp;
}
let a = {
  name: "a",
  children: {
    name: "a1",
  },
};
let b = shallowCopy(a);
b.name = "b";
b.children.name = "b1";
console.log(a);
```

```js
// 优化-手动实现
function shallowCopy(target){
    if(!(target instanceof Object) throw Error('传入的值必须为数组或者对象'));
    if(target instanceof Array){
        const newArr = [];
        target.forEach((item)=>newArr.push(item))
        return newArr
    }else{
        const newObj = {};
        Object.keys(target).forEach((key)=>newObj[key] = target[key]);
        return newObj
    }
}
```

### 深拷贝

浅拷贝的方法：`JSON.parse(JSON.stringify(obj))`等

```js
// JSON.parse(JSON.stringify(obj))
let a = {
  name: "a",
  children: {
    name: "a1",
  },
};
let b = { ...a };
b.name = "b";
b.children.name = "b1";
console.log(a);
```

`JSON.parse(JSON.stringify(obj))`方法的缺点：

- 会忽略 undefined
- 会忽略 symbol
- 不能序列化函数
- 不能解决循环引用的对象

```js
/**
 * 手动实现深拷贝
 */
// 判断是否为引用值
function isReferenceValue(target){
    return target instanceof Object
}
// 获取每项克隆后的值
function getCopyValue(target){
    return isReferenceValue(target) ? deepCopy(target) : target;
}
// 深拷贝
function  (target){
    if(!isReferenceValue(target)) throw Error('传入的值必须为数组或者对象');
    if(target instanceof Array){
        const newArr = [];
        const targetLen = target.length;
        for(let i = 0;i< targetLen; i++){
            newArr.push(getCopy(target[i]));
        }
        return newArr;
    }else{
        const newObj = {}
        for(let key in target){
            newObj[key] = getCopyValue(target[key]);
        }
        return newObj;
    }
}
```

> 参考文献

[1](https://juejin.im/post/6870027928508465160)

## 回调地狱，async await 的缺点

### 回调函数

在使用 JavaScript 时，为了实现某些逻辑经常会写出层层嵌套的回调函数，如果嵌套过多，会影响代码的可读性和逻辑，这种情况被称为回调地狱。

例如：

```js
let say = function (msg, callback) {
  setTimeout(() => {
    console.log(msg);
    callback(); // 回调函数
  }, 1000);
};

say("A", () => {
  say("B", () => {
    say("C", () => {
      console.log("-END-");
    });
  });
});
// 输出：A B C -END-
```

### 解决回调函数

1. 使用`Promise`的`then`或者`async`,`await`

```js
let say = function (msg) {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
        if(msg == 'B'){
          return reject('不能是B')
        }
        console.log(msg);
        resolve(); // 异步操作执行完后 执行 resolve()
    }, 1000);
  });
};
// 错误示范：还是进入了回调地狱且异常捕获麻烦
say("A").then(() => {
    say("B").then(() => {
        say("C").then(() => {
        console.log("-END-");
        });
    });
})
// 正解：then链式调用
say("A")
  .then(() => {
    return say("B"); //仍然返回一个 Promise 对象
  })
  .then(() => {
    return say("C");
  })
  .then(() => {
    console.log("-END-");
  })
  .catch((err) => {
    console.log(err);
  });

// 正解：使用async，await
(async function mouth(){
    try{
        let A = await say('A');
        let B = await say('B');
        let C = await say('C');
    }catch(err){
        console.log(err)
    }
})()
```

2. 使用`Generator`

```js
let say = function (msg) {
    setTimeout(() => {
        console.log(msg);
  });
};

function* sayList(){
    yield say('A', 1000);
    console.log('-END:A-');
    yield say('B', 1000);
    console.log('-END:B-');
    yield say('C', 1000);
    console.log('-END:C-');
}
// 方法一
let mouth = sayList();
mouth.next()
mouth.next()
mouth.next()
mouth.next()

// 方法二
let co = require('co'); // 引入co模块
co(sayList());
```

- [] promise 的原理及优缺点
- [] Map,Set
- [] 作用域链

* [] 事件循环 event loop
  - window
  - node

- [] 正则表达式
- [] 字符串重复次数
- [] new，bind 原理
